#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Попов Н.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Какие задачи удобным образом решаются методом поиска в пространстве состояний? 
Задачи, которые требуют нахожденя определенного пути.

Преимущество языка Prolog заключается в удобстве реализации подобных алгоритмов, так как сам Prolog выбирает свои решения при помощи поиска в глубину.

## Задание

Вдоль доски расположено 7 лунок, в которых лежат 3 черных и 3 белых шара. Передвинуть черные шары на место белых, а белые - на место черных. Шар можно передвинуть в соседнюю с ним пустую лунку, либо в пустую лунку, находящуюся непосредсвенно за ближайшим шаром.

*bbb_www -> www_bbb*


## Принцип решения

Для решения нам понадобится 3 основных вещи - факты состояний задачи, предикат перехода между состояниями и какой-нибудь вид поиска(в ширину, в глубину, поиск с итерационным погружением). Далее мы просто задаем начальное и конечное состояния задачи и запускаем поиск, который делает перебор переходов и ищет нужный путь. 


Опишем предикат вставки элемента в список `append(L1,L2,L3`:
```prolog
append([], L, L).
append([H|T], L, [H|TRES]) :- append(T, L, TRES).
```


Опишем предикат состояний `move(A,B)`:
```prolog
move(A,B) :- append(H, ['_','w'|T], A), append(H, ['w','_'|T], B).
move(A,B) :- append(H, ['w','_'|T], A), append(H, ['_','w'|T], B).
move(A,B) :- append(H, ['_','b'|T], A), append(H, ['b','_'|T], B).
move(A,B) :- append(H, ['b','_'|T], A), append(H, ['_','b'|T], B).
move(A,B) :- append(H, ['_','b','w'|T], A), append(H, ['w','b','_'|T], B).
move(A,B) :- append(H, ['_','w','b'|T], A), append(H, ['b','w','_'|T], B).
move(A,B) :- append(H, ['b','w','_'|T], A), append(H, ['_','w','b'|T], B).
move(A,B) :- append(H, ['w','b','_'|T], A), append(H, ['_','b','w'|T], B).
```


Опишем предикат перехода между состояними `next(L1,L2)`:
```prolog
next([X|T], [Y,X|T]) :- move(X, Y), not(member(Y, [X|T])).
```


Опишем предикаты поиска в ширину, глубину и поиска с итерационным погружением `bfs(X,Y)`, `dfs(X,Y)`, `search_id(X,Y)`:
```prolog
% Поиск в ширину.
bfs(X, Y) :- write(X), bdth([[X]], Y, Z), print(Z), !.
bdth([[H|T]|_], H, [H|T]).
bdth([H|T], X, Z) :- findall(W, next(H, W), Y), append(T, Y, E), !, bdth(E, X, Z).
bdth([_,T], X, Y) :- bdth(T, X, Y).

% Поиск в глубину.
dfs(X, Y) :- write(X), ddth([[X]], Y, Z), print(Z), !.
ddth([[H|T]|_], H, [H|T]).
ddth([H|T], X, Z) :- findall(W, next(H, W), Y), append(Y, T, E), !, ddth(E, X, Z).
ddth([_,T], X, Y) :- ddth(T, X, Y).

% Поиск с итерационным погружением.
natural(1).
natural(X):-
    natural(Y),
    X is Y + 1.

search_id(Beg,End):-
	natural(Depth),
	id([Beg],End,Path,Depth),
	reverse(Path,P),
	print(P),!.

id([B|List],B,[B|List],_).
id([L|List],B,Path,Depth):-
	next([L|List],Res),
	length(Res,Len),
	Len<Depth,
	id(Res,B,Path,Depth).
```

## Результаты

| Алгоритм Поиса     | Длина найденного первым пути         |  Время работы       |
|-------------------|--------------|---------------|
| В глубину |        70      |    0.66c           |
| В ширину |      16        |          0.96c     |
| ID |      16        |          0.34c     |

```prolog
?- dfs(['b','b','b','_','w','w','w'],['w','w','w','_','b','b','b']).
[b,b,b,_,w,w,w]
[b,b,b,w,_,w,w]
[b,b,_,w,b,w,w]
[b,b,w,_,b,w,w]
[b,b,w,b,_,w,w]
[b,b,w,b,w,_,w]
[b,b,w,_,w,b,w]
[b,b,w,w,_,b,w]
[b,b,w,w,b,_,w]
[b,b,w,w,b,w,_]
[b,b,w,w,_,w,b]
[b,b,w,_,w,w,b]
[b,b,_,w,w,w,b]
[b,_,b,w,w,w,b]
[b,w,b,_,w,w,b]
[b,w,b,w,_,w,b]
[b,w,b,w,w,_,b]
[b,w,b,w,w,b,_]
[b,w,b,w,_,b,w]
[b,w,b,_,w,b,w]
[b,w,_,b,w,b,w]
[b,_,w,b,w,b,w]
[_,b,w,b,w,b,w]
[w,b,_,b,w,b,w]
[w,b,b,_,w,b,w]
[w,b,b,w,_,b,w]
[w,b,b,w,b,_,w]
[w,b,b,w,b,w,_]
[w,b,b,w,_,w,b]
[w,b,b,_,w,w,b]
[w,b,_,b,w,w,b]
[w,_,b,b,w,w,b]
[_,w,b,b,w,w,b]
[b,w,_,b,w,w,b]
[b,w,w,b,_,w,b]
[b,w,w,b,w,_,b]
[b,w,w,b,w,b,_]
[b,w,w,b,_,b,w]
[b,w,w,_,b,b,w]
[b,w,_,w,b,b,w]
[b,_,w,w,b,b,w]
[_,b,w,w,b,b,w]
[w,b,_,w,b,b,w]
[w,b,w,_,b,b,w]
[w,b,w,b,_,b,w]
[w,b,w,b,b,_,w]
[w,b,w,b,b,w,_]
[w,b,w,b,_,w,b]
[w,b,w,b,w,_,b]
[w,b,w,_,w,b,b]
[w,b,w,w,_,b,b]
[w,b,w,w,b,_,b]
[w,b,w,_,b,w,b]
[w,b,_,w,b,w,b]
[w,_,b,w,b,w,b]
[_,w,b,w,b,w,b]
[b,w,_,w,b,w,b]
[b,w,w,_,b,w,b]
[b,w,w,w,b,_,b]
[b,w,w,w,_,b,b]
[b,w,w,_,w,b,b]
[b,w,_,w,w,b,b]
[b,_,w,w,w,b,b]
[_,b,w,w,w,b,b]
[w,b,_,w,w,b,b]
[w,_,b,w,w,b,b]
[w,w,b,_,w,b,b]
[w,w,b,w,_,b,b]
[w,w,_,w,b,b,b]
[w,w,w,_,b,b,b]
true.
```

```prolog
?- bfs(['b','b','b','_','w','w','w'],['w','w','w','_','b','b','b']).  
[b,b,b,_,w,w,w]
[b,b,b,w,_,w,w]
[b,b,_,w,b,w,w]
[b,_,b,w,b,w,w]
[b,w,b,_,b,w,w]
[b,w,b,w,b,_,w]
[b,w,b,w,b,w,_]
[b,w,b,w,_,w,b]
[b,w,_,w,b,w,b]
[_,w,b,w,b,w,b]
[w,_,b,w,b,w,b]
[w,w,b,_,b,w,b]
[w,w,b,w,b,_,b]
[w,w,b,w,_,b,b]
[w,w,_,w,b,b,b]
[w,w,w,_,b,b,b]
true.
```

```prolog
?- bfs(['b','b','b','_','w','w','w'],['w','w','w','_','b','b','b']).  
[b,b,b,_,w,w,w]
[b,b,b,w,_,w,w]
[b,b,_,w,b,w,w]
[b,_,b,w,b,w,w]
[b,w,b,_,b,w,w]
[b,w,b,w,b,_,w]
[b,w,b,w,b,w,_]
[b,w,b,w,_,w,b]
[b,w,_,w,b,w,b]
[_,w,b,w,b,w,b]
[w,_,b,w,b,w,b]
[w,w,b,_,b,w,b]
[w,w,b,w,b,_,b]
[w,w,b,w,_,b,b]
[w,w,_,w,b,b,b]
[w,w,w,_,b,b,b]
true.
```

```prolog
?- search_id(['b','b','b','_','w','w','w'],['w','w','w','_','b','b','b']). 
[b,b,b,_,w,w,w]
[b,b,b,w,_,w,w]
[b,b,_,w,b,w,w]
[b,_,b,w,b,w,w]
[b,w,b,_,b,w,w]
[b,w,b,w,b,_,w]
[b,w,b,w,b,w,_]
[b,w,b,w,_,w,b]
[b,w,_,w,b,w,b]
[_,w,b,w,b,w,b]
[w,_,b,w,b,w,b]
[w,w,b,_,b,w,b]
[w,w,b,w,b,_,b]
[w,w,b,w,_,b,b]
[w,w,_,w,b,b,b]
[w,w,w,_,b,b,b]
true.
```

## Выводы

Данная лабораторная работа научиа меня алгоритмами поиска на Prolog. 
Поиск в ширину (bfs) позволеят сразу найти кратчайший путь, однко использует больше памяти, чем поиск в глубину (dfs).
Также поиск в ширину может использоваться для нахождения пути с циклами, в отличие от поиска в глубину. Cамым оптимальным алгоритмом оказался поиск с итерационным погружением, так как его первое решение -кратчайший путь на поиск которого затрачивается столько же памяти как в поиске в глубину.



