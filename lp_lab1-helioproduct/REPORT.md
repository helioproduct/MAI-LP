# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Попов Н.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

Опишите своими словами, чем списки в языке Пролог отличаются от принятых в императивных языках подходов к хранению данных. На какие структуры
данных в традиционных языках похожи списки в Прологе?

## Задание 1.1: Предикат обработки списка

`remove_last_element(L,R)` - Удаление последнего элемента  

Примеры использования:
```prolog
?- remove_last_element([1, 2, 3], X).
X = [1, 2] 

?- remove_last_element([34, 5, 53, 3405], X).
X = [34, 5, 53] 
```

Реализация:
```prolog
remove_last_element(L, R) :- append(R, [_], L).
```

Отделяем головы у исходного и результирующего списков, 
если у исходного списка остался один элемент, список-результат должен быть пустым.

## Задание 1.2: Предикат обработки числового списка

`count_even(L,X)` - Вычисление числа четных элементов  

Примеры использования:
```prolog
?- count_even([1, 2, 3], X).
X = 1.

?- count_even([34, 5, 54, 105], X).
X = 2.
```

Реализация:
```prolog
count_even([],0).
count_even([H|Tail],C):-H mod 2=:=0,!,count_even(Tail,C1),C is C1+1.
count_even([_|Tail],C):-count_even(Tail,C).
```

Результат работы от пустого списка - 0.
Результатом работы от непустого списка является результат работы от хвоста списка, 
увеличенный на 1 при том условии, что голова списка четная.

## Задание 2: Реляционное представление данных

Реляционное представление - представление, основанное на отношениях между объектами, такое представление также часто называют табличным. Преимущества реляционного представления в удобном хранении информации, а также в отображении данных в достаточно простой и понятной форме. Недостатками реляционного представления данных заключается в том, что не все предментые области можно представить в виде таблиц, таблицы могут занимать относительно много внешней памяти.

В моем варианте представлений данных о студентах(one.pl) отношения представлены таким образом: student(102,'Петров'). subject('LP','Логическое программирование'). grade('Петровский','LP',5).

**Вариант 1**
- Получить таблицу групп и средний балл по каждой из групп
- Для каждого предмета получить список студентов, не сдавших экзамен (grade=2)
- Найти количество не сдавших студентов в каждой из групп

**1.Получить таблицу групп и средний балл по каждой из групп**

Для того, чтобы получить таблицу группы и средний балл по каждой из групп, нужно написать вспомогательные предикаты.

`sum([X|Y], S)` - вычисление суммы элементов списка. Разделим список на первый элемент и хвост. Рекурсивно ищем сумму элементов списка с конца. Если список пустой, сумма равна 0.

`average(X,T)` - вычисляет среднее арифметическое значение элементов списка. С помощью предиката `length` находим длину списка, а предикат `sum` находит сумму элементов списка. Поделив, находим среднее арифметическое значение элементов списка.

`student_average(Student, Res)` - вычисление среднего балла студента по всем предметам. С помощью предиката `findall` ищем оценки студента, а затем при помощи предиката `average(X,T)` вычисляем среднее арифметическое значение элементов списка оценок студента.

`students_average_in_group(Group, R)`- получает средний балл ученика в группе. 

`print_group_average()` - получение таблицы групп и средний балл по каждой из групп, а также печать номера группы и среднего балла для каждой группы. С помощью предиката `findall` создаём список, состоящий из номеров групп. Предикат `sort` упорядочивают список в соответствии со стандартным порядком и одновременно устраняет повторяющиеся элементы. Далее создаем список, который хранит в себе средние баллы студентов из группы, для этого используем предикат `students_average_in_group(Group, R)`. С помощью `average` рассчитываем средний балл группы и выводим его.

Реализация:
```prolog
sum([], 0).
sum([X|Y], S) :-
    sum(Y, Q),
    S is Q + X.

average(X, T) :-
    length(X, L),
    sum(X, P),
    T is P / L.

student_average(Student, R) :-
    findall(N, grade(Student, _, N), List),
    average(List, R).

students_average_in_group(Group, R) :-
    student(Group, Student),
    student_average(Student, R).

print_group_average() :-
    findall(Group, student(Group, _), Glist),
    sort(Glist, List),
    member(Group2, List),
    setof(R, students_average_in_group(Group2, R), ListValue),
    average(ListValue, Answer),
    write('Группа №'), write(Group2), write(' средний балл: '), write(Answer), write('\n'), fail.
```
Пример использования:
```prolog
?- print_group_average().
Группа №101 Средний балл: 3.916666666666667
Группа №102 Средний балл: 3.7291666666666665
Группа №103 Средний балл: 3.6
Группа №104 Средний балл: 3.7916666666666665
```

**2.Для каждого предмета получить список студентов, не сдавших экзамен (grade=2)**

`failed_exam()` - предикат, который вычисляет студентов, не сдавших экзамен и печатает их по каждому предмету. С помощью `subject(X,lesson)` получаем сокращенное название предмета, которое потом нам потребуется для предиката findall. Этот предикат ищет всех студентов, которые не сдали экзамен. С помощью команды `write` печатаем название предмета и фамилии студентов, не сдавших экзамен по этому предмету.

Реализация:
```prolog
failed_exam() :-
    subject(X, S),
    findall(N, grade(N, X, 2), L),
    write(S), write(' не сдали: '), write(L), write('\n'), fail.
```

Пример использования:
```prolog
?- failed_exam().
Логическое программирование не сдали: [Запорожцев,Эфиркина,Текстописов]
Математический анализ не сдали: [Запорожцев,Круглосчиталкин,Густобуквенникова,Криптовалютников,Блокчейнис,Азурин]
Функциональное программирование не сдали: [Криптовалютников]
Информатика не сдали: [Эфиркина,Джаво,Безумников]
Английский язык не сдали: [Эфиркина]
Психология не сдали: [Биткоинов,Текстописова,Криптовалютников,Азурин,Вебсервисов]
false.
```

**3.Найти количество не сдавших студентов в каждой из групп**

Для того, что бы найти количество не сдавших студентов в каждой из групп нужно написать вспомогательные предикаты.
`failed_student(Name,Group)` - находит студентов, которые не сдали экзамен.

`failed_in_group(Group,N)` - предикат, который по запросу номера группы, вычисляет количество не сдавших студентов в этой группе. С помощью предиката `setof` создаем список L, который хранит в себе фамилии студентов, не сдавших экзамен. Вычисляем длину этого списка с помощью предиката `length`

`number_failed()` - предикат, который находит количество не сдавших студентов в каждой из групп. С помощью предиката `findall` создаём список, состоящий из номеров групп. Предикат `sort` упорядочивают список в соответствии со стандартным порядком и одновременно устраняет повторяющиеся элементы. Для каждого значения из списка номеров групп вычисляем количество не сдавших студентов с помощью предиката `failed_in_group(Group,N)`. Выводим номер группы и количество не сдавших студентов в каждой из групп.

Реализация:
```prolog
failed_student(Name,Group) :-
    student(Group,Name),
    grade(Name,_,2).

failed_in_group(Group,N) :-
    setof(X,failed_student(X,Group),L),
    length(L,N).

number_failed():-
    findall(X, student(X, _), Glist),
    sort(Glist, List),
    member(Group, List),
    failed_in_group(Group, N),
    write('Группа: №'), write(Group), write(' не сдали: '), write(N), write('\n'), fail.
```
Пример использования:
```prolog
?- number_failed().
Группа: №101 не сдали: 2
Группа: №102 не сдали: 4
Группа: №103 не сдали: 3
Группа: №104 не сдали: 4
false.
```
## Выводы

Данная лабораторная работа научила меня работать со стандартными предикатами обработки списка. Я разобрался с основами языка, списками языка Prolog, написал предикаты обработки чисел списка, поработал с реляционным представлением данных. Я познакомился с принципами декларативного программирования, которое описывает, что представляет собой проблема и ожидаемый результат, в отличии от императивного, которое описывает, как решить задачу и представить результат. В Prolog реляционная база данных представляется в виде набора фактов, что позволяет использовать Prolog, как мощный язык запросов для баз данных. 