#№ Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Попов Н.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Опишите своими словами, какие подходы существуют к решению логических задач. Почему Prolog оказывается удобным языком для написания решателей таких задач?

Существует 2 основных подхода к решению логических задач: метод порождения и проверок и метод ветвей и границ. Они оба перебирают некоторый набор решений. Суть первого метода состоит в том, что некоторый предикат генерирует множество исходных данных, которые затем проверяются другими предикатами на предмет соответствия условию задачи. В случае неуспеха происходит возврат и рассмотрение следующего решения, в случае успеха полученное решение возвращается пользователю или используется дальше. Второй метод можно противопоставить первому. В методе ветвей и границ значительные части возможных решений отсекаются на раннем этапе выполнения или вообще не генерируются. Например, можно использовать предикат member одновременно для генерации и для проверки, таким образом генерируются не все варианты решений, а какое-то их подмножество. Очевидно, что программа, написанная с помощью второго метода, будет работать быстрее.

Пролог удобен для решения логических задач, потому что он дает возможность рассмотрения большого количества вариантов решения задачи и выбора из них подходящих. Механизм бэктрекинга при обнаружении неуспеха автоматически пересматривает решение и вытается продолжить выполнение программы при других значениях переменных.

## Задание

Дина, Соня, Коля, Рома и Миша учатся в институте. Их фамилии  Бойченко, Карпенко, Лысенко, Савченко и Шевченко. Мать Ромы умерла. Родители Дины никогда не встречались с родителями Коли. Студенты Шевченко и Бойченко играют в одной баскетбольной команде. Услышав, что родители Карпенко собираются поехать за город, мать Шевченко пришла к матери Карпенко и попросила, чтобы та отпустила своего сына к ним на вечер, но оказалось, что отец Коли уже договорился с родителями Карпенко и пригласил их сына к Коле. Отец и мать Лысенко  хорошие друзья родителей Бойченко. Все четверо очень довольны, что их дети собираются пожениться. Установите имя и фамилию каждого из молодых людей и девушек.

## Принцип решения

Предикат поиска решения get_result. Здесь определяется, как будет выглядеть ответ. Инициализируем фамилиями этот список, чтобы не искать их значения перебором. 


```prolog
Result = [person(AName, "Бойченко"), person(BName, "Карпенко"), person(CName, "Лысенко"), person(DName, "Савченк"), person(EName, "Шевченко")]
```

Затем происходит генерация вариантов ответов, в количестве 5^5=3125.
```prolog
name(AName), name(BName), name(CName), name(DName), name(EName)
```

Далее, используя написанные предикаты, описываем условия из задачи.

Описываем имена:


```prolog
name("Дина").
name("Соня").
name("Коля").
name("Рома").
name("Миша").
```

Опреляем пол каждого человека
```prolog
gender("Дина", female).
gender("Соня", female).
gender("Коля", man).
gender("Рома", man).
gender("Миша", man).
```

Предикаты сравнения пола: same_gender(X,Y) и на различие пола: not_same_gedner(X, Y).

```prolog
same_gender(X, Y) :- gender(X, Z), gender(Y, Z).
not_same_gender(X, Y) :- not(same_gender(X, Y)).
```

Наличие / Отсутствие мамы:

```prolog
has_mom(X) :- not(without_mom(X)).
without_mom("Рома").
```

Знакомы ли родители:

```prolog
parenets_not_familiar("Коля", "Дина").
parenets_familiar(X, Y) :- not(parenets_not_familiar(X, Y)), not(parenets_not_familiar(Y, X)).
```

Предикат get_result:


```prolog
get_result(Result) :-
    Result = [
		person(AName, "Бойченко"),
		person(BName, "Карепенко"),
		person(CName, "Лысенко"),
		person(DName, "Савченко"),
		person(EName, "Шевченко")
	],

	name(AName),
	name(BName),
	name(CName),
	name(DName),
	name(EName),

	%	Все переменные в ответе - это имена:
	%	При этом разные:
	util_unique([AName, BName, CName, DName, EName]),

	% 	При этом выполняются следующие условия:
	% 	у Карпенко сын
	gender(BName, man),

	%	имя Карпенко не будет Коля
	absolutely_not(BName, "Карепенко"),

	%	Шевченко и Бойченко в одной команде, поэтому, наверное, одного пола.
	same_gender(EName, AName),

	%	Лысенко и Бойченко хотят пожениться, поэтому, наверное, разного пола.
	not_same_gender(CName, AName),

	%	Мать Шевченко пришла к матери Карпенко, поэтому у них есть матери
	has_mom(EName),
	has_mom(BName),

	%	Отец и мать вчетвером дружат с родителями бойченко, поэтому у ниих тоже есть матери
	has_mom(CName),
	has_mom(AName),

	%	Шевченко знакомы с Карпенко
	parenets_familiar(EName, BName),

	%	Родители Коли знакомы с Карпенко
	parenets_familiar(BName, "Коля"),

	%	Лысенко и Бойченко хорошие друзья
	parenets_familiar(AName, CName).
```

Ответ:
```prolog
?- get_result(Result).
Result = [person("Соня", "Бойченко"), person("Миша", "Карепенко"), person("Коля", "Лысенко"), person("Рома", "Савченко"), person("Дина", "Шевченко")] 
```


## Выводы

В данной лабораторной работе я познакомился с методами решения логических задач на языке Prolog. Prolog удобен тем, что, описав ряд условий, мы отсекаем неподходящие варианты и находим нужное решение. Это удобно, если в задаче много условий или таких задач несколько. Также, если придется решать задачу, похожую на ту, что уже решал я, то мне нужно будет лишь поменять/добавить условия. 
На больших же данных, несомненно, Пролог будет очень полезен.
